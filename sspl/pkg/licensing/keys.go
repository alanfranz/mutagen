//go:build sspl

// Copyright (c) 2022-present Mutagen IO, Inc.
//
// This program is free software: you can redistribute it and/or modify it under
// the terms of the Server Side Public License, version 1, as published by
// MongoDB, Inc.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the Server Side Public License for more
// details.
//
// You should have received a copy of the Server Side Public License along with
// this program. If not, see
// <http://www.mongodb.com/licensing/server-side-public-license>.

package licensing

import (
	"crypto"
	"crypto/ed25519"
	"encoding/base64"
	"errors"
	"fmt"
	"sync"

	"github.com/golang-jwt/jwt/v4"
)

// keys maps Mutagen public key identifiers to their corresponding public keys.
// At the moment, all public keys are Base64-encoded ed25519 keys.
var keys = map[string]string{
	"io.mutagen.keys.licensing.key1": `Sr4tt6c/QPMbAcCeqwPw6Tr5lPyLVoof0jngiWnHVX0=`,
}

// processedKeys stores the deserialized versions of the keys in
// licenseKeys.
var processedKeys map[string]crypto.PublicKey

// initializeKeysOnce regulates invocation of initializeKeys.
var initializeKeysOnce sync.Once

// initializeKeysError stores any error generated by initializeKeys.
var initializeKeysError error

// initializeKeys initializes processedKeys.
func initializeKeys() {
	processedKeys = make(map[string]crypto.PublicKey, len(keys))
	for name, encoded := range keys {
		decoded, err := base64.StdEncoding.DecodeString(encoded)
		if err != nil {
			initializeKeysError = fmt.Errorf("unable to decode key (%s): %w", name, err)
			return
		} else if len(decoded) != ed25519.PublicKeySize {
			initializeKeysError = fmt.Errorf("key (%s) has invalid key size", name)
			return
		}
		processedKeys[name] = ed25519.PublicKey(decoded)
	}
}

// keyLookup is a key lookup function for parsing and validating JWTs.
func keyLookup(token *jwt.Token) (interface{}, error) {
	// Perform key initialization once and check for errors.
	initializeKeysOnce.Do(initializeKeys)
	if initializeKeysError != nil {
		return nil, fmt.Errorf("unable to initialize keys: %w", initializeKeysError)
	}

	// Attempt to look up the key.
	if kid, ok := token.Header["kid"]; !ok {
		return nil, errors.New("key identifier not present in token header")
	} else if keyName, ok := kid.(string); !ok {
		return nil, errors.New("key identifier has incorrect type")
	} else if key, ok := processedKeys[keyName]; !ok {
		return nil, fmt.Errorf("unknown key identifier: %s", keyName)
	} else {
		return key, nil
	}
}
